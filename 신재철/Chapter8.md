# URL 단축기 설계
tiny url 같은 URL 단축기를 설계하는 문제를 풀어보자.

## 1단계: 문제 이해 및 설계 범위 확정
개략적 추정
- 쓰기 연산: 매일 1억 개의 단축 URL 생성
- 초당 쓰기 연산: 1억 / 24 / 3600 = 1160
- 읽기 연산: 읽기 연산과 쓰기 연산 비율은 10:1 이라고 가정. 초당 11,600회 발생
- URL 단축 서비스를 10년 운영한다고 가정하면 1억 * 365 * 10 = 3650억 개의 레코드를 보관
- 축약 전 URL의 평균 길이는 100이라고 설정
- 10년 동안 필요한 저장 용량은 3650억 * 100바이트 = 36.5TB
 
## 2단계: 개략적 설개안 제시 및 동의 구하기

### API 엔드포인트
우리는 API 엔드포인트를 REST 스타일로 설계할 것이며, 두 개의 엔드포인트를 필요로 한다.

1. URL 단축용 엔드포인트: 새 단축 URL을 생성하고자 하는 클라이언트는 이 엔드포인트에 단축할 URL을 인자로 실어서 POST 요청을 보내야 한다.
POST /api/v1/data/shorten
- 인자: {longUrl: longURLstring}
- 반환: 단축 URL
2. URL 리디렉션용 엔드포인트: 단축 URL에 대해서 HTTP 요청이 오면 원래 URL로 보내주기 위한 용도의 엔드포인트
GET /api/v1/shorUrl
- 반환 : HTTP 리디렉션 목적지가 될 원래 URL

### URL 리디렉션
단축 URL을 받은 서버는 그 URL을 원래 URL로 바꾸어서 301 응답의 Location 헤더에 넣어서 반환한다.
![](https://github.com/sangminlee98/system-design-interview/assets/83197138/b159f13e-c653-4c61-a6dd-f20ad2e98d73)

301 응답과 302 응답이 비슷하면서 다른점이 있다.
- 301 Permanently Moved: 이 응답은 해당 URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답이다. 영구적으로 이전되었으므로, 브라우저는 이 응답을 캐시한다. 추후 다시 요청시 캐시된 응답을 활용하게 된다.
- 302 Found: 이 응답은 주어진 URL로의 요청이 '일시적으로' Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답이다. 따라서 단축 URL로 다시 요청을 보낼 때 언제나 다시 단축 URL로 먼저 요청을 보내게 된다.

이 두 방법은 각기 다른 장단점을 가지고 있다. 서버 부하를 줄이는게 중요하다면 301 응답을 사용할 수 있고, 클릭 발생률이나 발생 위치 등 트래픽 분석이 필요하다면 302를 쓰는게 더 유리하다.

URL 리디렉션을 구현하는 가장 직관적인 방법은 해시 테이블을 사용하는 것이다.

### URL 단축

![](https://github.com/sangminlee98/system-design-interview/assets/83197138/87615db8-c6a7-47b2-87e6-8b98d226543a)

이 해시 함수는 다음 요구사항을 만족해야 한다.
- 입력으로 주어지는 긴 URL이 다른 값이면 해시 값도 달라야 한다.
- 계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야 한다.

## 3단계: 상세 설계

### 데이터 모델
개략적 설계를 진행할 때는 모든 것을 해시 테이블에 두었다. 초기 전략으로는 괜찮지만 실제 시스템에서 쓰기에는 곤란한데, 메모리는 유한한 데다 비싸기 때문이다. 더 나은 방법은 순서쌍을 관계형 데이터베이스에 저장하는 것이다. 
![](https://github.com/sangminlee98/system-design-interview/assets/83197138/d7917b4c-82d2-4264-ba4d-7177d4f8e314)

### 해시 함수
해시 함수는 원래 URL을 단축 URL로 변환하는 데 쓰인다. 편의상 해시 함수가 계산하는 단축 URL 값을 hashValue라고 지칭하자.

#### 해시 값 길이
hashValue는 [0-9,a-z,A-Z]의 문자들로 구성된다. 따라서 사용할 수 있는 문자의 개수는 10+26+26=62개다.
hashValue의 길이를 정하기 위해서는 3650억인 n의 최솟값을 찾아야 한다. 

62^n >= 3650억인 n의 최솟값을 찾아야 한다!

n이 7이면 3.5조 개의 URL을 만들 수 있다. 

#### 해시 후 충돌 해서
긴 URL을 줄이려면, 원래 URL을 7글자 문자열로 줄이는 해시 함수가 필요하다. 손쉬운 방법은 CRC32, MD5, SHA-1같이 잘 알려진 해시 함수를 이용하는 것이다.

```
해시 함수	해시 결과 (16진수)
CRC32	    5cb54054
MD5	        5a62509a84df9ee03fe1230b9df8b84e
SHA-1	    0eeae7916c06853901d9ccbefbfcaf4de56ed85b
```

CRC32가 계산한 해시 값이 7보다 크므로, 줄이기 위해선 7자리 까지만 이용하는 것이다. 하지만 이렇게 하면 해시 결과가 충돌할 확률이 높아진다. 충돌이 발생하면, 충돌이 해소될 때까지 사전에 정한 문자열을 해시값에 덧붙인다.
![](https://github.com/sangminlee98/system-design-interview/assets/83197138/21e60f25-0a05-41ef-8384-ebe03f2fb5b0)

이 방법을 쓰면 충돌은 해소할 수 있지만, 데이터베이스를 한 번 이상 질의해야 하므로 오버헤드가 크다. 
DB 대신 블룸 필터를 사용하면 성능을 높일 수 있다.

#### base-62 변환
진법 변환(base conversion)은 URL 단축기를 구현할 때 흔히 사용되는 접근법중 하나다. 

10진수로 11157을 62진수(진법)을 하면 2TX

11157(10진수) = 2 x 62^2 + 55 x 62 ^1 + 59 x 62 ^ 0 = [2, 55, 59] => [2, T, X] => 2TX(62진수)이다.

#### 두 접근법 비교

```
해시 후 충돌 해소 전략	                    
- 단축 URL의 길이가 고정됨	                
- 유일성이 보장되는 ID 생성기가 필요치 않음	  
- 충돌이 가능해서 해소 전략이 필요	          
- ID로부터 단축 URL을 계산하는 방식이 아니라서 다음에 쓸 수 있는 URL을 알아내는 것이 불가능	ID가 

base-62 변환
- 단축 URL의 길이가 가변적. ID값이 커지면 같이 길어짐
- 유일성 보장 ID 생성기가 필요
- ID의 유일성이 보장된 후에야 적용 가능한 전략이라 충돌은 아예 불가능
- 1씩 증가하는 값이라고 가정하면 다음에 쓸 수 있는 단축 URL이 무엇인지 쉽게 알아낼 수 있어서 보안상 문제가 될 소지가 있음
```

### URL 단축기 상세 설계
처리 흐름 순서도
![](https://github.com/sangminlee98/system-design-interview/assets/83197138/8224a57a-6655-46eb-a06b-3b6b02146e2c)

- 입력된 URL이 https://en.wikipedia.org/wiki/Systems_design이라고 하자.
- 이 URL에 대해 ID 생성기가 반환한 ID는 2009215674938
- 이 ID를 62진수로 변환하면 zn9edcu를 얻는다.
- 아래와 같은 데이터베이스 레코드를 만든다.
```
ID	shortURL	longURL
2009215674938	zn9edcu	https://en.wikipedia.org/wiki/Systems_design
```

### URL 리디렉션 상세 설계
쓰기보다 읽기를 더 자주 하는 시스템이라, <단축 URL, 원래 URL>의 쌍을 캐시에 저장하여 성능을 높였다.
![](https://github.com/sangminlee98/system-design-interview/assets/83197138/12c7f7ab-a3c4-4922-8077-3d4d478888ab)

## 4단계: 마무리
설계를 마친 후에 다음을 더 고민해볼 수 있다.

- 처리율 제한 장치(rate limiter): 엄청난 양의 단축 요청이 밀려들어 오면 무력화될 수 있다는 잠재적 보안 결함을 갖고 있다. rate limiter를 두면, IP 주소를 비롯한 필터링 규칙으로 요청을 걸러낼 수 있을 것이다. 
- 웹 서버의 규모 확장: 본 설계에 포함된 웹 계층은 무상태(stateless) 계층이므로, 웹 서버를 자유로이 증설하거나 삭제할 수 있다.
- 데이터 분석 솔루션(analytics): 성공적인 비지니스를 위해서는 데이터가 중요하다. 어떠 링크를 얼마나 많은 사용자가 클릭했는지, 언제 주로 클릭했는지 등 중요한 정보를 알아낼 수 있을 것이다.
- 가용성, 데이터 일관성, 안정성: 대규모 시스템이 성공적으로 운영되기 위해서는 반드시 갖추어야 할 속성들이다.
