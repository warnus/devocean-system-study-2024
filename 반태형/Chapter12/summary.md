# 채팅 시스템 설계

## 문제 이해 및 설계 범위 확정
* 응답 지연이 낮은 1대1 채팅
* 최대 100명까지 참여가능한 그룹 채팅
* 사용자 접속 상태 표시 기능
* 다양한 단말 지원. 하나의 계정으로 여러 단말에 동시 접속 지원
* 푸시 알림
* 5천만 DAU

## 2단계 개략적 설계안 제시 및 동의 구하기
* 채팅 시스템의 경우 클라이언트는 서로 직접 통신하지 않고 채팅 서비스와 통신한다.
* 기본기능
  * 클라이언트들로부터 메시지 수신
  * 메시지 수신자 결정 및 전달
  * 수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관
* 채팅을 위해서는 어떤 통신 프로토콜을 사용하는가가 중요하다.
  * http 프로토콜을 사용한다.
  * Keep-alive 헤더를 사용하면 클라이언트-서버 사이의 연결을 끊지 않고 계속 유지할 수 있다. TCP의 핸드쉐이크 횟수도 줄일 수 있다.
  * 폴링, 롱폴링, 웹소켓 등이 있다.

### 웹 소켓
* HTTP 핸드쉐이크 - ack - 메시지 양방향 전송
* 웹 소켓 연결은 클라이언트가 시작한다. 한 번 맺어진 연결은 항구적이며 양방향이다.
* HTTP 연결 이후 웹소켓 연결로 업그레이드 된다.

### 개략적 설계안
* 채팅서비스는 웹 소켓
* 서비스 디스커버리
  * 클라이언트가 접속할 채팅 서버의 DNS 호스트 명을 클라이언트에게 알려주는 역할
* 상태 유지 서비스
  * 서버가 살아있는한 다른 서버로 연결을 변경하지 않는다.
* 규모 확장성
  * 이론적으로는 모든 사용자 연결을 최신 클라우드 서버 한 대로 처리할 수 있긴 하다.
  * 채팅 서버는 클라이언트 사이에 메시지를 중계하는 역할을 담당한다.
  * 접속 상태 서버는 사용자의 접속 여부를 관리한다.
  * 키 값 저장소에는 채팅 이력을 보관한다. 시스템에 접속한 사용자는 이전 채팅 이력을 전부 볼 수 있다.
* 데이터 모델
* 1대1

| message      | type      |
|--------------|-----------|
| message_id   | bigint    |
| message_from | bigint    |
| message_to   | bigint    |
| content      | text      |
| created_at   | timestamp |

* 그룹채팅

| message      | type      |
|--------------|-----------|
| channel_id   | bigint    |
| message_id   | bigint    |
| message_to   | bigint    | 
| content      | text      |
| created_at   | timestamp |
*** message from 이 아닌가?

* 메시지 id는 고유하며 정렬가능한 것이 좋다.
* 지역적 순서 번호 생성기 - 같은 그룹 안에서만 보증하면 되는 경우

## 3단계 상세 설계
* 서비스 탐색
  * 클라이언트에게 적합한 채팅 서버를 추천해야 한다.
    * 지역정보, 서버 용량 등이 있으며 아파치 주키퍼같은 것이 있다.
    * 사용자 A가 로그인을 시도하여 API 서버로 보내고 인증이 성공하고 나면 채팅 서버를 찾는다.
    * 사용자는 채팅서버와 웹소킷 연결을 한다.
* 메시지 흐름
  * 1대1
    * 사용자 A , B 가 각각 채팅서버에 연결된다.
    * 사용자가  메시지를 서버로 전송하면 서버는 ID 를 받아오고 메시지를 큐로 보낸다. 메시지가 키-값 저장소에 보관된다.
    * 접속 중이라면 채팅서버로 전송, 아니라면 알람을 보낸다.
    * 채팅 서버2는 메시지를 사용자 B에게 전송
  * 여러 단말 사이의 메시지 동기화
    * 한 사람이 여러 단말을 사용할 수 있다.
    * 스마트폰에서 채팅앱에 로그인한 결과로 채팅서버에 연결되고 데스크톱도 마찬가지이다. 각 단말이 current_max_message_id 를 가지고 있다.
    * 아래 조건을 만족한다면 새 메시지이다.
      * 수신자 ID가 현재 로그인한 사용자 ID 와 같다
      * 키-값 저장소에 보관된 메시지로서 그 ID 가 current_max_message_id 보다 크다.
  * 소규모 그룹
    * 한 명이 보낸 메시지가 메시지 동기화 큐에 복사된다.
    * 새로운 메시지가 왔는지 확인하려면 자기 큐만 보면 되니까 단순하다.
    * 그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 작업의 비용이 문제되지 않는다.
      * 그룹 최대 500명정도의 위챗이 위와 같은 방식을 사용한다.
    * 한 수신자는 여러 사용자의 메시지를 받아야 한다.
* 접속 상태 표시
  * 접속 상태 서버로 사용자 상태를 관리
  * 사용자 로그인
    * 접속하고나면 접속 시점을 저장한다.
  * 로그아웃 
    * 키 값 저장소에 저장된 상태가 오프라인으로 바꾼다.
  * 접속 장애
    * 하트비트를 이용한다.
    * 몇 초 이내에 이벤트를 받으면 살아있고 아니면 오프라인으로 변경한다.
    * 사용자가 적다면 그룹내의 사용자 별로 세 개의 채널에 각각 쓰는 것이 가능하다.
    * 너무 많다면 수동갱신 유도, 접속할 때만 받아가는 등의 방식이 필요하다
## 4단계 마무리
* 채팅 서버 -웹소켓
* 키 값 저장소
* 메시지 ID
* 푸시알림
* 다루지 않은 주제들
  * 암호화
  * 캐시
  * 로딩 속도 개선
  * 오류처리
