# key-value 저장소 설계
- 비관계형 데이터베이스
- 고유 식별자를 키로 갖고 그에 대응하는 값이 함께 저장 (pair)
  - 키는 유일해야 하며 값은 키를 통해서만 접근 가능
   - 키는 일반 텍스트이거나 해시 값
   - 성능상의 이유로 키는 짧을 수록 좋다.
- AWS DynamoDB, Redis 등

## 문제 이해 및 설계 범위 확정
- 읽기/쓰기/메모리 사용량 사이에 어떤 균형을 찾고 데이터의 일관성과 가용성 사이에서 타협적 결정을 내려야 한다.

아래와 같은 특성을 갖는 키-값 저장소 설계
1. 키-값 쌍의 크기는 작음: 10KB 이하
2. 대용량 데이터 저장 가능
3. 높은 가용성: 장애가 발생해도 시스템이 빠르게 응답함
4. 높은 확장성: 대용량 데이터를 지원하도록 시스템 확장 가능
5. 자동 확장: 트래픽에 따라 서버의 추가/삭제가 자동으로 이루어짐
6. 조정 가능한 데이터 일관성
7. 낮은 응답 지연 시간

## 단일 서버 키-값 저장소
한 대 서버에 모든 키-값 데이터를 메모리에 해시 테이블로 저장하는 방법이 가장 구현하기 쉽다. 하지만 빠른 속도를 보장할 수 있더라도 모든 데이터를 메모리 안에 두는 것이 어려울 수 있다.

따라서, 문제를 해결하기 위한 개선책으로
- 데이터 압축
- 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장

이렇게 개선하더라도 한 대 서버로는 부족할 때가 찾아 올 것이다. (많은 데이터 저정 불가능, SPOF 문제 등등)

## 분산 키-값 저장소(분산 해시 테이블)

### CAP 정리 - 세가지를 동시에 만족하는 분산 시스템을 설계하는 것은 불가능!
세가지 가운데 어떤 두가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다는 것을 의미하는 정리이다.
- Consistency: 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐와 관계없이 언제나 같은 데이터를 보게 되어야 한다.
- Availability: 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.
- Partition tolerance: 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 파티션 감내는 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다.

![스크린샷 2024-06-02 오후 6 45 45](https://github.com/warnus/devocean-system-study-2024/assets/58351498/a1cff526-db40-4367-8374-ea4df5f8b84b)

키-값 저장소는 세 가지 요구사항 가운데 어느 것을 만족하냐에 따라 분류할 수 있다.
- CP 시스템: 일관성, 파티션 감내를 지원
- AP 시스템: 가용성과 파티션 감내를 지원
- CA 시스템: 일관성과 가용성을 지원하는 저장소. 실제로 존재하지 않음

C, A는 분산 시스템의 특성이지만 P는 그 분산시스템이 돌아가는 네트워크에 대한 특성이다. P는 네트워크가 임의의 메시지 손실을 할 수 있다는 것을 허용하는 여부이다. 즉, 네트워크가 장애가 발생할 수 있다는 것을 인정하는 것이다.

P를 제외하려면 장애가 절대로 발생하지 않는 네트워크를 구성해야지만 현실적으로는 불가능하다. 따라서 P는 최종적으로 선택되어야 하며 나머지 하나는 C이거나 A일 수 밖에 없다.

분산 시스템에서 데이터는 보통 여러 노드에 복제되어 보관된다. 세 대의 복제 노드 n1, n2, n3에 데이터를 복제하여 보관하는 상황을 아래와 같이 가정.

#### 이상적인 상태
이상적 환경에서 네트워크가 파티션되는 상황은 절대로 일어나지 않을 것이다. n1에 기록된 데이터는 자동적으로 n2와 n3에 복제되고 데이터 일관성과 가용성도 만족된다.

#### 하지만, 현실은 다르다
분산 시스템은 파티션 문제를 피할 수 없고 문제가 발생하면 일관성과 가용성 사이에서 하나를 선택할 수 밖에 없다.

![스크린샷 2024-06-02 오후 6 51 58](https://github.com/warnus/devocean-system-study-2024/assets/58351498/0e2906e9-8769-4bbb-bce9-3c4308d15534)

n3에 장애가 발생하여 n1, n2와 통신할 수 없는 상황을 가정해보자.

클라이언트가 n1, n2에 기록한 데이터는 n3로 전달되지 않고 n3에는 기록되었지만 아직 n1과 n2에 전달되지 않은 데이터가 있다면 n1과 n2는 오래된 사본을 가지고 있을 것이다.

- 일관성을 택한다면
  n1과 n2에 대해서도 쓰기 연산을 중단시킨다.
- 가용성을 택한다면
  계속 읽기 연산을 허용해야한다. n1, n2에서의 쓰기 연산도 허용할 것이다. 파티션 문제가 해결되면 새 데이터를 n3에 전송할 것이다.

### 시스템 컴포넌트
키-값 저장소에 구현에 사용될 핵심 컴포넌트와 기술

#### 데이터 파티션
대규모의 애플리케이션의 경우, 전체 데이터를 하나의 서버에 욱여넣을 수 없으므로.. 작은 파티션으로 분할한 다음 여러대의 서버에 저장해야 한다.

데이터를 파티션 단위로 나눌 떄의 주의점
1. 데이터를 여러 서버에 고르게 분산할 수 있는가
2. 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가

5장에서 나온 안정해시가 문제를 해결하는 데 적합한 기술이다.

안정 해시를 사용하여 데이터를 파티션하면 좋은 점
1. 규모 확장 자동화: 시스템 부하에 따라 서버가 자동으로 추가되거나 삭제됨
2. 다양성: 각 서버의 용량에 맞게 가상 노드의 수를 조정 가능, 고성능 서버는 더 많은 가상 노드를 갖도록 설정할 수 있음

#### 데이터 다중화
고가용성과 안정성 확보를 위해 데이터를 N개의 서버에 비동기적인 다중화가 필요하다.
- N: 튜닝 가능한 값

N개의 서버를 선정하는 방법
- 어떤 키를 해시 링 위에 배치 후, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개의 서버에 데이터 사본을 보관한다.

따라서, N=3에서 key0은 s1, s2, s3에 저장된다.

![스크린샷 2024-06-02 오후 6 59 09](https://github.com/warnus/devocean-system-study-2024/assets/58351498/9cd85cb0-d5a7-4e4b-8294-59c977bbfe04)

하지만, 가상 노드를 사용한다면 위와 같이 선택한 N개 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있다. 따라서 노드를 선택할 때 같은 물리 서버를 중복 선택하지 않도록 해야 한다.

#### 데이터 일관성
