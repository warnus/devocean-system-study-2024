# 처리율 제한 장치의 설계
> rate limiter: 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치 </br>
> ex) 특정 기간 내에 전송되는 클라이언트의 HTTP request 횟수를 제한 </br>
>     - 사용자는 초당 2회 이상 새 글을 올릴 수 없음 </br>
>     - 같은 IP 주소로는 하루에 10개 이상의 계정 생성 불가 </br>
>     - 같은 디바이스로는 주당 5회 이상 리워드 요청 불가 </br>

**rate limiter의 장점**
1. DoS 공격 방지 - 추가 요청에 대해서는 처리를 중단함으로써 공격 차단
2. 비용 절감 - 서버를 불필요하게 많이 두지 않아도 됨
3. 서버 과부하 방지 - 봇, 잘못된 이용으로 발생한 트래픽을 걸러낼 수 있음

## 1단계) 문제 이해 및 설계 범위 확정
### 요구사항
1. 처리율을 초과하는 요청은 정확히 제한
2. 낮은 응답시간
3. 적은 메모리 사용
4. 분산형 처리율 제한: 하나의 rate limiter를 여러 서버나 프로세스에서 공유 -> "동기화 문제"
5. 예외 처리: 걸러진 요청이라면 사용자에게 알려야 함
6. 높은 결함 감내성: 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어선 안됨

## 2단계) 개략적 설계안 제시 및 동의 구하기
### 처리율 제한 장치는 어디에 둘 것인가?

#### 클라이언트 측에 제한 장치를 두는 방법
일반적으로 클라이언트는 처리율 제한을 안정적으로 걸 수 있는 장소가 아님
- 클라이언트 요청은 쉽게 위변조가 가능하기 때문
- 또한, 모든 클라이언트의 구현을 통제하는 것도 어려움

#### 서버 측에 제한 장치를 두는 방법
1. 서버에 제한 장치를 두는 방법

![스크린샷 2024-05-19 오후 2 00 22](https://github.com/warnus/devocean-system-study-2024/assets/58351498/83156425-1de4-489e-8a85-e94e217f0865)

2. 처리율 제한 장치가 미들웨어가 되어 API 서버로 가는 요청을 통제하는 방법
![스크린샷 2024-05-19 오후 2 01 46](https://github.com/warnus/devocean-system-study-2024/assets/58351498/14ccf97a-2ffb-448b-843a-c8c378a29811)

API 서버의 처리율이 초당 2개로 제한된 상황, 클라이언트가 3번째 요청을 앞의 두 요청과 같은 초 범위 내에서 전송하였다고 가정

앞의 2개의 요청을 API 서버로 전송될 것이지만, 세번째 요청은 처리율 제한 미들웨어에 의해 가로막혀 HTTP status code 429가 반환
- 429 상태 코드: 사용자가 너무 많은 요청을 보내려고 했음(Too many requests)

클라우드 마이크로서비스에서 라면, 처리율 제한 장치는 API gateway로 구현됨
- API gateway: 처리율 제한, SSL 종단, 사용자 인증, IP 화이트리스트 관리 등을 지원하는 클라우드 서비스

#### 처리율 제한 장치를 두는 위치
- 프로그래밍 언어, 캐시 서비스 등 현재 사용하고 있는 기술 스택 점검
- 사업에 필요한 처리율 제한 알고리즘을 찾아라 (서버 측에서 모든 것을 구현한다면 알고리즘 자유롭게 선택가능, 게이트웨이 서비스를 사용한다면 선택지 제한)
- MSA 기반에 사용자 인증, IP 화이트리스트 처리를 위해 API gateway를 이미 설계에 포함했다면 처리율 제한 기능도 게이트웨이에 포함시켜야할 수 있음
- 처리율 제한 서비스를 직접 만드는데 시간이 듦 -> 상용 API gateway를 쓰는 것 추천

### 처리율 제한 알고리즘 
#### 토큰 버킷 알고리즘
토큰 버킷은 지정된 용량을 갖는 컨테이너, 이 버킷에 사전 설정된 양의 토킨이 주기적으로 채워짐

토큰이 꽉 찬 버킷에는 더 이상 버킷이 추가되지 않고 버려짐

토큰 버킷 용량이 4이고 매초 2개의 토큰이 추가되는 예제

![스크린샷 2024-05-19 오후 2 25 13](https://github.com/warnus/devocean-system-study-2024/assets/58351498/72cb08c6-e314-4b36-a56e-19085b499595)

- 각 요청은 처리될 떄마다 하나의 토큰을 사용
- 요청이 도착하면 버킷에 충분한 토큰이 있는지 검사
    - 토큰이 있다면, 버킷에서 토큰 하나를 꺼내고 요청을 시스템에 전달
    - 토큰이 없다면, 요청은 버려짐
 
![스크린샷 2024-05-19 오후 2 32 32](https://github.com/warnus/devocean-system-study-2024/assets/58351498/3e203314-22bb-4670-a034-937002d00c9d)

토큰 버킷의 크기가 4이고, 토큰 공급률이 분당 4인 토큰 버킷 알고리즘 처리 제한 로직
![스크린샷 2024-05-19 오후 2 39 34](https://github.com/warnus/devocean-system-study-2024/assets/58351498/48435722-f908-4b97-8496-4219689cf376)

**토큰 버킷 알고리즘에서 필요한 2개 인자**
- 버킷 크기: 버킷에 담을 수 있는 토큰의 최대 개수
- 토큰 공급률: 초당 몇개의 토큰이 버킷에 공급되는지

**버킷 개수 적용 사례**
- 통상적으로 API endpoint마다 별도의 버킷을 둠
  - 사용자마다 하루 한번만 포스팅 / 친구는 150명까지 추가 / 좋아요는 5번까지 가능하다면 사용자마다 3개의 버킷을 둠
  - IP주소별로 처리율 제한을 적용한다면 IP주소마다 버킷을 하나씩 할당
  - 시스템 처리율을 초당 10,000개로 제한한다면 모든 요청이 하나의 버킷을 공유하도록 구현

**장점**
1. 구현이 쉽다
2. 메모리 사용 측면에서도 효율적
3. 짧은 시간에 집중되는 트래픽 처리 가능(버킷에 남은 토큰이 존재하기만 하면 요청은 시스템으로 전달됨)

**단점**
1. 버킷 크기와 토큰 공급률이라는 두개의 인자를 적절히 튜닝하는 것은 까다로움

#### 누출 버킷 알고리즘
토큰 버킷 알고맂므과 비슷하지만 요청 처리율이 고정되어 있다는 차이점이 있음, 그리고 FIFO 큐로 구현됨

![스크린샷 2024-05-19 오후 4 07 00](https://github.com/warnus/devocean-system-study-2024/assets/58351498/32345505-8a42-4553-a89a-b54335566821)

- 요청이 도착하면 큐가 가득차있는지 확인
- 빈자리가 있다면, 큐에 요청 추가
- 가득차 있다면, 새 요청은 버림
- 지정된 시간마다 큐에서 요청을 꺼내어 처리

**누출 버킷 알고리즘의 두가지 인자**
- 버킷 크기: 큐 사이즈
- 처리율: 지정된 시간당 몇 개의 항목을 처리할지 지정하는 값(보통 초단위)

**장점**
1. 큐의 크기가 제한되어 있어 메모리 사용량에서 효율적
2. 고정된 처리율을 갖고 있어 안정적 출력이 필요한 경우에 적합

**단점**
1. 단시간에 많은 트래픽이 몰리게 되면 큐에 오래된 요청이 쌓이게 되어 그 요청을 제떄 처리 못하게 되면 최신 요청들은 버려지게 됨
2. 두 개의 인자를 튜닝하기가 까다로움

#### 고정 윈도 카우넡 알고리즘
- 타임라인을 고정된 간격의 window로 나누고 각 윈도우마다 counter를 붙임
- 요청이 접수될 때마다 카운터의 값 1씩 증가
- 카운터의 값이 사전에 설정된 임계치에 도달하면 새로운 요청은 새 윈도가 열릴 때까지 버려짐

![image](https://github.com/warnus/devocean-system-study-2024/assets/58351498/407458c7-1344-4e18-a02e-645c35fb7a61)

**문제점**

윈도우의 경계 부근에 순간적으로 많은 트래픽이 집중될 경우 윈도우에 할당된 양보다 더 많은 요청이 처리될 수 있음

![image](https://github.com/warnus/devocean-system-study-2024/assets/58351498/0a2ab725-c0f9-4bf6-b15f-fd28b7caa552)

최대 5개의 요청만 허용하는 시스템에서 카운터는 매분마다 초기화

2:00:00 ~ 2:01:00 사이에 5개의 요청이 들어왔고, 2:01:00 ~ 2:02:00 사이에 또 5개의 요청이 들어옴

윈도우 위치를 옮겨 2:00:30 ~ 2:01:30까지 1분 동안 시스템이 총 10개의 요청을 처리함 (허용 한도의 2배)

**장점**
1. 메모리 효율이 좋음
2. 윈도우가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기에 적합

**단점**
1. 윈도우 경계 부근에서 일시적으로 많은 트래픽이 몰려드는 경우, 기대했던 시스템의 처리 한도보다 많은 양의 요청을 처리하게 됨

#### 이동 윈도 로깅 알고리즘


