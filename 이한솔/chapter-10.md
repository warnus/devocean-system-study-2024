## 1단계) 문제 이해 및 설계 범위 확정
- 푸시 알림, sms 메시지, 이메일 알람 지원
- solft real-time 지원, 시스템에 높은 부하가 생겼을 경우 약간의 지연은 가능
- iOS, 안드로이드, 랩톱/데스크톱 지원
- 클라이언트 애플리케이션 프로그램이나 서버측에서 스케줄링하여 사용자에게 알림 생성
- 사용자는 더이상 알림을 받지 않도록 설정 가능
- 하루에 천만건 모바일 푸시 알림, 백만건의 sms 메시지, 5백만 건의 이메일 전송 가능해야 함

## 2단계) 개략적 설계안 제시 및 동의 구하기
### 알림 유형별 지원 방안
#### iOS 푸시 알림
![스크린샷 2024-07-01 오후 1 16 27](https://github.com/mardi2020/devocean-system-study-2024/assets/58351498/104e97c9-1561-4054-afe6-99343b05bb2d)
- 알림 제공자(Provider): 알림 요청을 생성해 애플 푸시 알림서비스(APNS)로 보내는 주체
- 알림 요청을 생성하기 위한 데이터들
  - device token: 알림 요청을 보내는데 필요한 고유 식별자
  - payload: 알림 내용을 담은 JSON 딕셔너리
    ``` json
    {
      "aps": {
        "alert": {
          "title": "Game Requst",
          "body": "Bob wants to play chess",
          "action-loc-key": "PLAY"
        },
        "badge": 5
      }
    }
    ```
  - APNS: 애플이 제공하는 원격 서비스, 푸시 알림을 iOS 장치로 보내는 역할
  - iOS 단말: 푸시 알림을 수신하는 사용자 단말
#### 안드로이드 푸시 알림
![스크린샷 2024-07-01 오후 1 20 16](https://github.com/mardi2020/devocean-system-study-2024/assets/58351498/6dbdbd03-3c88-4f39-aee6-53ba7dcec64e)

APNS 대신 FCM(Firebase Cloud Messaging)을 사용

#### SMS 메시지
![스크린샷 2024-07-01 오후 1 20 42](https://github.com/mardi2020/devocean-system-study-2024/assets/58351498/4c62b5ae-5b44-453d-a960-b814d3f2b47d)

Twilio, Nexmo 같은 제 3사업자의 서비스를 통해 사용 요금을 지불하고 사용

#### 이메일
![스크린샷 2024-07-01 오후 1 21 13](https://github.com/mardi2020/devocean-system-study-2024/assets/58351498/4548926c-5366-441c-ad92-552eacc54599)

자사에서 고유 이메일 서버 구축할 순 있지만, Sendgird 등 상용 서비스를 이용하여 전송 성공률을 보장하고 데이터 분석 서비스를 활용할 수 있음

### 연락처 정보 수집 절차
알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 주소 등의 정보가 필요하다. 그림과 같이 사용자가 우리 앱을 설치하거나 처음으로 계정을 등록하면 API 서버는 해당 사용자의 정보를 수집하여 데이터베이스에 저장한다.

![스크린샷 2024-07-01 오후 6 39 16](https://github.com/mardi2020/devocean-system-study-2024/assets/58351498/9ee1e748-1e38-4b00-a92d-512be1fb1bdb)

데이터베이스에 연락처 정보를 저장할 테이블 구조

![스크린샷 2024-07-01 오후 6 40 05](https://github.com/mardi2020/devocean-system-study-2024/assets/58351498/a45d2877-4667-4eb0-a8dc-533af5bb82a9)
- user table: 이메일 주소, 전화번호 등 저장
- device table: 단말 토큰 저장

한 사용자가 여러 단말을 가질 수 있거 알림은 모든 단말에 전송되어야 한다는 점을 고려

### 알림 전송 및 수신 절차
#### 개략적 설계 초안
![스크린샷 2024-07-01 오후 6 40 34](https://github.com/mardi2020/devocean-system-study-2024/assets/58351498/5f2ccf84-9eb9-4c47-9286-a48bca404b35)

- 1부터 N까지의 서비스: 마이크로서비스/크론잡/분산 시스템 컴포넌트일 수 있다
  - ex) 사용자에게 납기일을 알리는 과금 서비스
- 알림 시스템: 알림 전송/수신의 핵심, 이 시스템은 1 ~ N까지의 서비스에게 알림 전송을 위한 API를 제공해야하고 제3자 서비스에 전달할 알림 페이로드를 만들어 내야한다
- 제3자 서비스: 사용자에게 실제 알람을 전달
  - 확장성에 유의
  - 중국같은 곳에서는 사용이 불가할 수도 있음
- iOS, 안드로이드, SMS, 이메일 단말: 사용자는 자신의 단말에서 알림을 수신함

❌ 이 설계 초안의 문제점
- SPOP(Single-Point-Of-Failure): 알림 서비스에 서버가 하나밖에 없다는 것은 그 서버에 장애가 생기면 전체 서비스의 장애로 이어진다는 뜻
- 규모 확장성: 한 대 서비스로 푸시 알림에 관계된 모든 것을 처리하므로, 데이터베이스나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 방법이 없다.
- 성능 병목: 알림을 처리하고 보내는 것은 자원을 많이 필요로 하는 작업일 수 있다.
  - 예를 들어 HTML 페이지를 만들고 제3자 서비스의 응답을 기다리 는 일은 시간이 많이 걸릴 가능성이 있는 작업이다. 따라서 모든 것을 한 서버로 처리하면 사용자 트래픽이 많이 몰리는 시간에는 시스템이 과부하 상태에 빠질 수 있다.

### 개략적 설계안 (개선된 버전)
초안의 문제점을 개선한 설계안
- ﻿﻿데이터베이스와 캐시를 알림 시스템의 주 서버에서 분리
- ﻿﻿알림 서버를 증설하고 자동으로 수평적 규모 확장이 이루어질 수 있도록한다.
- ﻿﻿메시지 큐를 이용해 시스템 컴포넌트 사이의 강한 결합을 끊는다.

![스크린샷 2024-07-01 오후 6 41 19](https://github.com/mardi2020/devocean-system-study-2024/assets/58351498/83f5b33d-6804-490f-8155-2ad72bdfc593)

- 1부터 N까지의 서비스: 알림 시스템 서버의 API를 통해 알림을 보낼 서비스
- ﻿﻿알림 서버(noticaton Server)는 다음 기능을 제공
    알림 전송 API: 스팸 방지를 위해 보통 사내 서비스 또는 인증된 클라이언트만 이용 가능
    알림 검증(validation): 이메일 주소, 전화번호 등에 대한 기본적 검증을 수행
    데이터베이스 또는 캐시 질의: 알림에 포함시킬 데이터를 가져오는 기능
    ﻿﻿알림 전송: 알림 데이터를 메시지 큐에 넣는다. 본 설계안의 경우 하나 이상의 메시지 큐를 사용하므로 알림을 병렬적으로 처리 가능

-  캐시(cache): 사용자 정보, 단말 정보, 알림 템플릿등을 캐시
- 데이터베이스(DB): 사용자, 알림, 설정 등 다양한 정보를 저장한다.
- ﻿﻿메시지 큐: 시스템 컴포넌트 간 의존성을 제거하기 위해 사용한다. 다량의 알림이 전송되어야 하는 경우를 대비한 버퍼 역할도 한다.
    본 설계안에서는 알림의 종류별로 별도 메시지 큐를 사용하였다. 따라서 제 3자 서비스 가운데 하나에 장애가 발생해도 다른 종류의 알림은 정상 동작하게 된다.
- ﻿﻿작업 서버(workers): 메시지 큐에서 전송할 알림을 꺼내서 제3자 서비스로 전달하는 서버
- ﻿﻿제3자 서비스
- ﻿﻿iOS，안드로이드, SMS, 이메일 단말

이제 이 컴포넌트들이 어떻게 협력하여 알림을 전송하게 되는지 살펴보자.
1. ﻿﻿﻿API를 호출하여 알림 서버로 알림을 보낸다.
2. ﻿﻿﻿알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 메타데이터를 캐시나 데이터베이스에서 가져온다.
3. 알림 서버는 전송할 알림에 맞는 이벤트를 만들어서 해당 이벤트를 위 한 큐에 넣는다. 
    iOS 푸시 알림 이벤트는 iOS 푸시 알림 큐에 추가
4. 작업 서버는 메시지 큐에서 알림 이벤트를 꺼낸다.
5. 작업 서버는 알림을 제3자 서비스로 보낸다.
6. ﻿﻿﻿제3자 서비스는 사용자 단말로 알림을 전송한다.

## 3단계) 상세 설계
### 안정성
분산 환경에서 운영될 알림 시스템을 설계할 때는 안정성을 확보하기 위한 몇가지 사항을 반드시 고려

#### 데이터 손실 방지
알림 전송 시스템의 가장 중요한 요구사항 가운데 하나는 어떤 상황에서도 알림이 소실되면 안 된다는 것
- 알림이 지연되거나 순서가 틀려도 괜찮지만, 사라지면 곤란

이 요구사항을 만족하려면 알림 시스템은 알림 데이터를 데이터베이스에 보관하고 재시도 메커니즘을 구현해야 한다. 그림과 같이 알림 로그(notification log) 데이터베이스를 유지하는 것이 한가지 방법이다.

![스크린샷 2024-07-01 오후 6 41 38](https://github.com/mardi2020/devocean-system-study-2024/assets/58351498/1859597f-90dc-4684-ab47-bc2791465fdc)

#### 알림 중복 전송 방지
분산 시스템의 특성상 가끔은 같은 알림이 중복되어 전송되기도 할 것이다. 그 빈도를 줄이려면 중복을 탐지하는 메커니즘을 도입하고, 오류 신중하게 처리 필수

간단한 중복 방지 로직의 사례
- 보내야 할 알림이 도착하면 그 이벤트 ID를 검사하여 이전에 본 적이 있는 이벤트인지 확인
  - 중복된 이벤트라면 버리고, 그렇지 않으면 알림을 발송

중복 전송을 100% 방지하는 것이 왜 불가능한지..? -> 
https://bravenewgeek.com/you-cannot-have-exactly-once-delivery/
-  네트워크 분할, 시스템 오류, 메시지 중복 등을 고려할 때 정확히 한 번의 전달을 보장할 수 없으며, 대신 적어도 한 번(at-least-once) 전달을 통해 유사한 효과를 달성하는 방법을 제안

### 추가로 필요한 컴포넌트 및 고려사항
지금부터는 알림 템플릿, 알림 설정, 이벤트 추적, 시스템 모니터링, 처리율 제한 등 알림 시스템 구현을 위해 필요한 추가 컴포넌트들에 대해 알아보자.

#### 알림 템플릿
대형 알림 시스템은 하루에도 수백만 건 이상의 알림을 처리한다. 그런데 그 알림 메시지 대부분은 형식이 비슷하다. 알림 템플릿은 이런 유사성을 고려하여, 알림 메시지의 모든 부분을 처음부터 다시 만들 필요 없도록 해 준다. 

알림 템플릿은 인자(parameter)나 스타일, 추적 링크(tracking link)를 조정하기만 하면 사전에 지정한 형식에 맞춰 알람을 만들어 내는 틀

#### 알림 설정
많은 웹사이트와 앱에서는 사용자가 알림 설정을 상세히 조정할 수 있도록 하고 있다. 

이 정보는 알림 설정 테이블에 저장되고 이 테이블에는
- user_id
- channel: 알림이 저장될 채널
- opt_in: 해당 채널로 알림을 받을 것인지의 여부

특정 종류의 알림을 보내기 전에 반드시 해당 사용자가 해당 알림을 켜 두었는지 확인

#### 전송률 제한
사용자에게 너무 많은 알림을 보내지 않도록 하는 한 가지 방법은, 한 사용자가 받을 수 있는 알림의 빈도를 제한하는 것이다. 

알림을 너무 많이 보내기 시작하면 사용자가 알림 기능을 아예 꺼버릴 수도 있기 때문이다.

#### 재시도 방법
제3자 서비스가 알림 전송에 실패하면, 해당 알림을 재시도 전용 큐에 넣는다.

같은 문제가 계속해서 발생하면 개발자에게 통지

#### 푸시 알림과 보안
iOS나 안드로이드에서의 알림 전송 API는 appkey와 appSecret을 사용해 보안 유지

즉, 인증되거나 승인된 클라이언트만 API를 호출하여 사용하여 알림 전송
#### 큐 모니터링
알림 시스템을 모니터링 할 때 중요한 메트릭은 큐에 쌓인 알림의 개수이다. 
- 이 수가 너무 크면 작업 서버들이 이벤트를 빠르게 처리하고 있지 못함(크다는게 어느정도인지)
- 그런 경우에는 작업 서버를 증설

#### 이벤트 추적
알림 확인율, 클릭율, 실제 앱 사용으로 이어지는 비율 같은 메트릭은 사용자를 이해하는데 중요하다. 데이터 분석 서비스는 보통 이벤트 추적 기능도 제공한다. 따라서 보통 알림 시스템을 만들면 데이터 분석 서비스와도 통합해야만 한다. (실제 활용 사례가 궁금)

- 데이터 분석 서비스를 통해 추적하게 될 알림 시스템 이벤트의 사례

![스크린샷 2024-07-01 오후 6 41 56](https://github.com/mardi2020/devocean-system-study-2024/assets/58351498/dcbff8e2-1cc2-4561-9cad-01b2c2926e4b)

(오류가 발생하면 그 뒤는..?)

### 수정된 설계안
![스크린샷 2024-07-01 오후 6 42 27](https://github.com/mardi2020/devocean-system-study-2024/assets/58351498/1db7f578-b0a6-416b-ad74-81f42d84df10)

설계안에 새롭게 추가된 컴포넌트
- 알림 서버에 인증과 전송률 제한기능이 추가
- 전송 실패에 대응하기 위한 재시도 기능이 추가
- 전송에 실패한 알림은 다시 큐에 넣고 지정된 횟수만큼 재시도(횟수를 지정하는건 어떻게 정할까?)
- 전송 템플릿을 사용하여 알림 생성 과정을 단순화하고 알림 내용의 일관성 유지
- 모니터링과 추적 시스템을 추가하여 시스템 상태를 확인하고 추후 시스템을 개선하기 쉽도록 함
## 4단계) 마무리
알림은 중요 정보를 계속 알려준다는 점에서 필요불가결한 기능
- ﻿﻿안정성(reliability): 메시지 전송 실패율을 낮추기 위해 재시도 메커니즘을 도입
- ﻿﻿보안(security): 인증된 클라이언트만이 알림을 보낼 수 있도록 appKey, appSecret 등의 메커니즘을 이용
- ﻿﻿이벤트 추적 및 모니터링: 알림이 만들어진 후 성공적으로 전송되기까지의 과정을 추적하고 시스템 상태를 모니터링하기 위해 알림 전송의 각 단계마다 이벤트를 추적하고 모니터링할 수 있는 시스템 통합
- ﻿﻿사용자 설정: 사용자가 알림 수신 설정을 조정할 수 있도록 하였다. (알림 on/off 먼저 확인)
- 전송한 제한: 사용자에게 알람을 보내는 빈도 제한
  
